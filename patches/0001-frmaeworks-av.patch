diff --git a/include/media/IOMX.h b/include/media/IOMX.h
index 1c39b9c..cda2204 100644
--- a/include/media/IOMX.h
+++ b/include/media/IOMX.h
@@ -233,6 +233,13 @@ struct omx_message {
             OMX_U32 range_length;
             OMX_U32 flags;
             OMX_TICKS timestamp;
+#ifdef MTK_HARDWARE
+            //for transmitting proprietary data
+            OMX_U32 token_tick;
+            OMX_U32 token_VA;
+            OMX_U32 token_PA;
+            OMX_U32 token_FD;
+#endif
         } extended_buffer_data;
 
         // if type == FRAME_RENDERED
diff --git a/include/media/stagefright/CameraSource.h b/include/media/stagefright/CameraSource.h
index c2e75a6..31afc33 100644
--- a/include/media/stagefright/CameraSource.h
+++ b/include/media/stagefright/CameraSource.h
@@ -317,6 +317,10 @@ private:
     CameraSource &operator=(const CameraSource &);
 };
 
+#ifdef MTK_HARDWARE
+int32_t getColorFormatByMTK(const char* colorFormat);
+#endif
+
 }  // namespace android
 
 #endif  // CAMERA_SOURCE_H_
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index a6558ab..b1d107d 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -936,6 +936,14 @@ status_t StagefrightRecorder::start() {
 }
 
 sp<MediaCodecSource> StagefrightRecorder::createAudioSource() {
+#ifdef MTK_HARDWARE
+    //MTK80721 HDRecord 2011-12-23
+    if ((mAudioEncoder == AUDIO_ENCODER_AAC || mAudioEncoder == AUDIO_ENCODER_HE_AAC || mAudioEncoder == AUDIO_ENCODER_AAC_ELD) && mSampleRate < 16000)
+    {
+        ALOGD("encode profile tuning:encode:%d,samplerate:%d,min smplerate=16K",mAudioEncoder, mSampleRate);
+        mSampleRate = 16000;
+    }
+#endif
     int32_t sourceSampleRate = mSampleRate;
 
     if (mCaptureFpsEnable && mCaptureFps >= mFrameRate) {
@@ -1832,9 +1840,22 @@ status_t StagefrightRecorder::pause() {
         return OK;
     }
 
+#ifdef MTK_HARDWARE
+    if((mOutputFormat == OUTPUT_FORMAT_AMR_NB ||
+          mOutputFormat == OUTPUT_FORMAT_AMR_WB)
+          &&mAudioEncoderSource != NULL){
+            ALOGW("AMR will pause writer for support stop after pause");
+            mWriter->pause();
+    }else{
     if (mAudioEncoderSource != NULL) {
         mAudioEncoderSource->pause();
     }
+    }
+#else
+    if (mAudioEncoderSource != NULL) {
+        mAudioEncoderSource->pause();
+    }
+#endif
     if (mVideoEncoderSource != NULL) {
         mVideoEncoderSource->pause();
     }
@@ -1885,6 +1906,13 @@ status_t StagefrightRecorder::resume() {
         if (source == nullptr) {
             continue;
         }
+#ifdef MTK_HARDWARE
+        if (mOutputFormat == OUTPUT_FORMAT_AMR_NB || mOutputFormat == OUTPUT_FORMAT_AMR_WB) {
+            ALOGD("AMR Recording pause-resume");
+            mWriter->start();
+            continue;
+        }
+#endif
         source->setInputBufferTimeOffset((int64_t)timeOffset);
         source->start();
     }
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index a11494d..8c178c8 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -212,6 +212,35 @@ struct CodecObserver : public BnOMXObserver {
                             omx_msg.u.extended_buffer_data.timestamp);
                     msg->setInt32(
                             "fence_fd", omx_msg.fenceFd);
+#ifdef MTK_HARDWARE
+                    msg->setInt32(
+                            "ticks",
+                            omx_msg.u.extended_buffer_data.token_tick);
+                if( 0x00010000 == (0x00010000 & omx_msg.u.extended_buffer_data.flags) )
+                {
+                   msg->setInt32(
+                            "token_VA",
+                            omx_msg.u.extended_buffer_data.token_VA);
+                    msg->setInt32(
+                            "token_PA",
+                            omx_msg.u.extended_buffer_data.token_PA);
+                    msg->setInt32(
+                            "token_FD",
+                            omx_msg.u.extended_buffer_data.token_FD);
+                }
+                else
+                {
+                    msg->setInt32(
+                            "token_VA",
+                            0);
+                    msg->setInt32(
+                            "token_PA",
+                            0);
+                    msg->setInt32(
+                            "token_FD",
+                            0);
+                }
+#endif
                     break;
                 }
 
@@ -2768,6 +2797,12 @@ status_t ACodec::setupAACCodec(
     if (encoder && isADTS) {
         return -EINVAL;
     }
+#ifdef MTK_HARDWARE  //Error handling for WhatsApp issue.
+    if (encoder && sampleRate == 44000)
+    {
+        sampleRate = 44100;
+    }
+#endif
 
     status_t err = setupRawAudioFormat(
             encoder ? kPortIndexInput : kPortIndexOutput,
@@ -3899,7 +3934,20 @@ status_t ACodec::setupVideoEncoder(
 
     video_def->nSliceHeight = sliceHeight;
 
+#ifdef MTK_HARDWARE //for continus shot feature
+    ALOGD("nStride %d, nSliceHeight %d", video_def->nStride, video_def->nSliceHeight);
+    //support RGB565 and RGB888 size
+    if( colorFormat == OMX_COLOR_Format16bitRGB565 )
+        def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 2);
+    else if( colorFormat == OMX_COLOR_Format24bitRGB888 )
+        def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 3);
+    else if( colorFormat == OMX_COLOR_Format32bitARGB8888 )
+        def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 4);
+    else
     def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 3) / 2;
+#else
+    def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 3) / 2;
+#endif
 
     float frameRate;
     if (!msg->findFloat("frame-rate", &frameRate)) {
@@ -5141,6 +5189,16 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                             rect.nWidth = videoDef->nFrameWidth;
                             rect.nHeight = videoDef->nFrameHeight;
                         }
+#ifdef MTK_HARDWARE
+                    if (!strncmp(mComponentName.c_str(), "OMX.MTK.", 8) && mOMX->getConfig(
+                            mNode, (OMX_INDEXTYPE) 0x7f00001c /* OMX_IndexVendorMtkOmxVdecGetCropInfo */,
+                            &rect, sizeof(rect)) != OK) {
+                        rect.nLeft = 0;
+                        rect.nTop = 0;
+                        rect.nWidth = videoDef->nFrameWidth;
+                        rect.nHeight = videoDef->nFrameHeight;
+                    }
+#endif
 
                         if (rect.nLeft < 0 ||
                             rect.nTop < 0 ||
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index e708f68..8c313f7 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -202,6 +202,12 @@ LOCAL_C_INCLUDES += \
 	$(TOP)/hardware/samsung/exynos4/include
 endif
 
+ifeq ($(strip $(BOARD_USES_MTK_HARDWARE)),true)
+LOCAL_SHARED_LIBRARIES += \
+   libdpframework \
+	libmtkcam_fwkutils
+endif
+
 LOCAL_MODULE:= libstagefright
 
 LOCAL_MODULE_TAGS := optional
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 8707d96..0184c73 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -43,6 +43,9 @@
 #else
 #define UNUSED_UNLESS_VERBOSE(x)
 #endif
+#ifdef MTK_HARDWARE
+#include "MtkCameraParameters.h"
+#endif
 
 namespace android {
 
@@ -113,10 +116,21 @@ void CameraSourceListener::postRecordingFrameHandleTimestamp(nsecs_t timestamp,
 }
 
 static int32_t getColorFormat(const char* colorFormat) {
+#ifdef MTK_HARDWARE
+    if(colorFormat == NULL){
+        ALOGW("camera colorFrmat is NULL!");
+        return -1;
+    }
+    int32_t result = getColorFormatByMTK(colorFormat);
+    if(result != -1){
+        return result;
+    }
+#else
     if (!colorFormat) {
         ALOGE("Invalid color format");
         return -1;
     }
+#endif
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P)) {
        return OMX_COLOR_FormatYUV420Planar;
@@ -1337,4 +1351,17 @@ void CameraSource::DeathNotifier::binderDied(const wp<IBinder>& who __unused) {
     ALOGI("Camera recording proxy died");
 }
 
+#ifdef MTK_HARDWARE
+int32_t getColorFormatByMTK(const char* colorFormat) {
+    ALOGD("getColorFormat(%s)", colorFormat);
+    if (!strcmp(colorFormat, MtkCameraParameters::PIXEL_FORMAT_YUV420I)) {
+       return OMX_COLOR_FormatYUV420Planar; // i420
+    }
+    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P) ) {
+       return OMX_MTK_COLOR_FormatYV12;// YV12
+    }
+    return -1;
+}
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/colorconversion/Android.mk b/media/libstagefright/colorconversion/Android.mk
index 0bf9701..904fa68 100644
--- a/media/libstagefright/colorconversion/Android.mk
+++ b/media/libstagefright/colorconversion/Android.mk
@@ -1,4 +1,5 @@
 LOCAL_PATH:= $(call my-dir)
+ifneq ($(strip $(BOARD_USES_MTK_HARDWARE)),true)
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=                     \
@@ -20,3 +21,4 @@ LOCAL_SANITIZE := signed-integer-overflow
 LOCAL_MODULE:= libstagefright_color_conversion
 
 include $(BUILD_STATIC_LIBRARY)
+endif
\ No newline at end of file
diff --git a/media/libstagefright/omx/OMX.cpp b/media/libstagefright/omx/OMX.cpp
index d6fb2b2..fec6630 100644
--- a/media/libstagefright/omx/OMX.cpp
+++ b/media/libstagefright/omx/OMX.cpp
@@ -724,6 +724,24 @@ OMX_ERRORTYPE OMX::OnFillBufferDone(
     msg.u.extended_buffer_data.range_length = pBuffer->nFilledLen;
     msg.u.extended_buffer_data.flags = pBuffer->nFlags;
     msg.u.extended_buffer_data.timestamp = pBuffer->nTimeStamp;
+#ifdef MTK_HARDWARE
+    //for transmitting proprietary data
+    msg.u.extended_buffer_data.token_tick = pBuffer->nTickCount;
+    msg.u.extended_buffer_data.token_VA = 0;
+    msg.u.extended_buffer_data.token_PA = 0;
+    msg.u.extended_buffer_data.token_FD = 0;
+    if( 0x00010000 == (0x00010000 & pBuffer->nFlags) )
+    {
+        //OMX_U32 CMInfo[0x8] = {0};
+        OMX_U32 *CMPtr = (OMX_U32 *)pBuffer->pPlatformPrivate;
+        if( NULL != pBuffer->pPlatformPrivate )
+        {
+           msg.u.extended_buffer_data.token_VA = *(CMPtr+2);
+            msg.u.extended_buffer_data.token_PA = *(CMPtr+3);
+            msg.u.extended_buffer_data.token_FD = *(CMPtr+7);
+        }
+    }
+#endif
 
     sp<OMX::CallbackDispatcher> callbackDispatcher = findDispatcher(node);
     if (callbackDispatcher != NULL) {
diff --git a/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp b/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp
index 409cef7..3591eee 100644
--- a/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp
+++ b/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp
@@ -488,6 +488,18 @@ OMX_ERRORTYPE SoftVideoDecoderOMXComponent::internalSetParameter(
             uint32_t oldHeight = def->format.video.nFrameHeight;
             uint32_t newWidth = video_def->nFrameWidth;
             uint32_t newHeight = video_def->nFrameHeight;
+#ifdef MTK_HARDWARE
+            // 20150126 Marcus Huang: Fix ALPS01919422; limits the max width/height
+            //@Vdec_drv_if_public.c
+            //  DEC_MAX_WIDTH = 1920;
+            //  DEC_MAX_HEIGHT = 1088;
+#define MAX_SUPPORT_WIDTH 1920
+#define MAX_SUPPORT_HEIGHT 1088
+            if ((newWidth * newHeight) > (MAX_SUPPORT_WIDTH * MAX_SUPPORT_HEIGHT)) {
+                ALOGE("frame size is not supported (%d x %d)", newWidth, newHeight);
+                return OMX_ErrorUnsupportedSetting;
+            }
+#else
             // We need width, height, stride and slice-height to be non-zero and sensible.
             // These values were chosen to prevent integer overflows further down the line, and do
             // not indicate support for 32kx32k video.
@@ -496,6 +508,7 @@ OMX_ERRORTYPE SoftVideoDecoderOMXComponent::internalSetParameter(
                 ALOGE("b/22885421");
                 return OMX_ErrorBadParameter;
             }
+#endif
             if (newWidth != oldWidth || newHeight != oldHeight) {
                 bool outputPort = (newParams->nPortIndex == kOutputPortIndex);
                 if (outputPort) {
diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index e8c80c1..6147603 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -6462,6 +6462,7 @@ reacquire_wakelock:
         mTimestamp.mPosition[ExtendedTimestamp::LOCATION_SERVER] += framesRead;
         mTimestamp.mTimeNs[ExtendedTimestamp::LOCATION_SERVER] = systemTime();
 
+#ifndef MTK_HARDWARE
         // Update server timestamp with kernel stats
         if (mInput->stream->get_capture_position != nullptr
                 && mPipeSource.get() == nullptr /* don't obtain for FastCapture, could block */) {
@@ -6477,6 +6478,7 @@ reacquire_wakelock:
                 // as the read obtains a lock, preventing the timestamp call from executing.
             }
         }
+#endif
         // Use this to track timestamp information
         // ALOGD("%s", mTimestamp.toString().c_str());
 				 
